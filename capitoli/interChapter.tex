%Andrea Borghesi
%Università degli studi di Bologna

%capitolo dedicato all'interazione tra ottimizzatore e simulatore

\documentclass[12pt,a4paper,openright,twoside]{report}
\usepackage[italian]{babel}
\usepackage{indentfirst}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{titlesec,blindtext, color}
\usepackage[font={small,it}]{caption}
\usepackage{subfig}
\usepackage{listings}
\usepackage{color}
\usepackage{url}
\usepackage{textcomp}
\usepackage{eurosym}
\usepackage{amsmath}
\usepackage{url}

%impostazioni generali per visualizzare codice
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
 
\lstset{ %
  basicstyle=\footnotesize,           % the size of the fonts that are used for the code
  backgroundcolor=\color{white},      % choose the background color. You must add \usepackage{color}
  numbers=left,                   % where to put the line-numbers
  numberstyle=\tiny\color{gray},  % the style that is used for the line-numbers
  numbersep=5pt,  
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
  rulecolor=\color{black}, 
  tabsize=2,                      % sets default tabsize to 2 spaces
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  title=\lstname,                   % show the filename of files included with \lstinputlisting;
  frame=single,                   % adds a frame around the code
                                  % also try caption instead of title
  keywordstyle=\color{blue},          % keyword style
  commentstyle=\color{dkgreen},       % comment style
  stringstyle=\color{mauve},         % string literal style
  escapeinside={\%*}{*)},            % if you want to add LaTeX within your code
  morekeywords={*,...},              % if you want to add more keywords to the set
  deletekeywords={...}              % if you want to delete keywords from the given language
}

%per avere un bordo intorno alle figure
\usepackage{float}
\floatstyle{boxed} 
\restylefloat{figure}

%per poter poi impedire che certe parole vadano a capo
\usepackage{hyphenat}

%ridefinisco font per fancyhdr, per ottenere un'intestazione pulita
\newcommand{\changefont}{ \fontsize{9}{11}\selectfont }
\fancyhf{}
\fancyhead[LE,RO]{\changefont \slshape \rightmark} 	%section
\fancyhead[RE,LO]{\changefont \slshape \leftmark}	%chapter
\fancyfoot[C]{\changefont \thepage}					%footer

%titolo capitolo con "numero | titolo"
\definecolor{gray75}{gray}{0.75}
\newcommand{\hsp}{\hspace{20pt}}
\titleformat{\chapter}[hang]{\Huge\bfseries}{\thechapter\hsp\textcolor{gray75}{|}\hsp}{0pt}{\Huge\bfseries}


\oddsidemargin=30pt \evensidemargin=20pt

%sillabazioni non eseguite correttamente
\hyphenation{sil-la-ba-zio-ne pa-ren-te-si si-mu-la-to-re ge-ne-ra-re pia-no}

%interlinea
\linespread{1.15}  
\pagestyle{fancy}

%cartelle contenenti le immagini
\graphicspath{{/media/sda4/tesi/immagini/grafici/}{/media/sda4/tesi/immagini/grafici/incCompare/}{/media/sda4/tesi/immagini/grafici/rawData/}{/media/sda4/tesi/immagini/grafici/regressionAnalysis/}{/media/sda4/tesi/immagini/schemi/}{/media/sda4/tesi/immagini/simulazione/}{/media/sda4/tesi/immagini/epolicy/}{/media/sda4/tesi/immagini/ottimizzazione/}
{/media/sda4/tesi/immagini/interazione/}}

%in modo che dopo il titolo di un paragrafo il testo vada a capo
\newcommand{\myparagraph}[1]{\paragraph{#1}\mbox{}\\}

%per scrivere bene CLP(R) e CLP(FD)
\newcommand{\clpr}{CLP({\ensuremath{\cal R}})}
\newcommand{\clpfd}{CLP({\ensuremath{\cal FD}})}

\begin{document}

\chapter{\nohyphens{INTERAZIONE COMPONENTI}}
Nei capitoli precedenti abbiamo descritto gli elementi principali che concorrono a definire l'architettura del sistema ePolicy (certamente all'interno del progetto sono presente ulteriori componenti, come quello dedicato all'opinion mining, ma in questo caso ci riferiamo a quelli considerati in questo lavoro). Da un punto di vista generale essi sono il modello a vincoli che garantisce una ottimizzazione a livello globale e il simulatore che studia il comportamento delle modalità di incentivazione a livello locale/regionale. Un aspetto molto importante è quindi capire come gestire l'interazione tra ottimizzatore e simulatore in modo ottimale, in modo da integrare le prospettive globale e locale.

Possiamo illustrare la necessità di comprendere a fondo questa interazione con un esempio. Supponiamo che la fase di ottimizzazione abbia prodotto due scenari alternativi, il primo concentrandosi sulla creazione di impianti a biomassa e il secondo sostenendo la costruzione di centrali idroelettriche; entrambi i piani avrebbero un impatto non indifferente sui cittadini. La produzione energetica con la biomassa comporta un impatto sostanziale sulle aree boschive, potenziale inquinamento del suolo e delle coltivazioni, inquinamento dell'aria nelle aree urbane vicine alla centrale; d'altra parte, le centrali idroelettriche prevedono l'allagamento vaste porzioni di territorio. In ogni caso le strategie per implementare il piano, studiate tramite il simulatore, dovrebbero tenere in considerazione questi effetti sugli individui; le attività di implementazione implicherebbero quindi costi aggiuntivi che dovrebbero essere inseriti come nuovi vincoli all'interno dell'ottimizzatore, il quale potrebbe poi effettuare nuovamente la fase di pianificazione, con la possibilità di ottenere risultati diversi. 

Un approccio molto basilare sarebbe il semplice scambio di risultati tra i due livelli di pianificazione delle politiche, svolgendo anche diverse iterazioni, ma questo metodo rischierebbe di non garantire la convergenza. A un certo punto le iterazioni possono essere fermate quando un equilibrio è stato raggiunto o quando il decisore politico valuta che ulteriori aggiustamenti non siano più necessari o richiesti. Citando Clement Attlee\footnote{Fonte: A. Sampson, \emph{Anatomy of Britain}, Hodder \& Stoughton, 1962} \emph{``Democracy means government by discussion but it is only effective if you can stop people talking.''} - democrazia significa governo fondato sulla discussione, ma funziona solamente se si riesce a far smettere la gente di discutere.
\\*

Il tema dell'integrazione efficacie tra pianificazione regionale e simulazione è oggetto di intensa ricerca per ottenere una soluzione ottimale all'interno del progetto ePolicy (in modo particolare servendosi di metodologie appartenenti alla \emph{teoria dei giochi}); nel resto del capitolo verrà mostrato un possibile approccio, da noi implementato e messo alla prova con il problema dell'assegnazione dei fondi regionali per l'incentivazione della tecnologia fotovoltaica in Emilia-Romagna.

\section{INTEGRARE DSS E SIMULAZIONI}
Un primo approccio a cui è possibile pensare, consiste nello sfruttare i metodi e le tecniche dell'\emph{Apprendimento Automatico} (noto in letteratura anche come \emph{Machine Learning}), il quale rappresenta un'area dell'Intelligenza Artificiale che si occupa della realizzazione di sistemi e algoritmi che si basano su serie di osservazioni e dati per la sintesi di nuova conoscenza. Senza voler entrare nel dettaglio, possiamo comunque citare una definizione comunemente accettata di Apprendimento Automatico: \emph{``Un programma apprende da una certa esperienza E se, con rispetto a una classe di compiti T e una misura delle prestazioni P, le prestazioni P nello svolgere un compito dell'insieme T sono migliorate dall'esperienza E''} \cite{Mitchell}.
 
Nel nostro caso abbiamo sfruttato le tecniche di regressione viste nei capitoli precedenti per ricavare le relazioni che legano i fondi destinati agli incentivi regionali con la produzione elettrica di energia elettrica fotovoltaica, partendo dalle serie di dati forniti dal simulatore, affinché fosse poi possibile inserirle all'interno dell'ottimizzatore sotto forma di ulteriori vincoli, da tenere in considerazione per la fase di pianificazione. Il nostro fine è stato quello di estrarre dalla grande quantità di dati generata dal simulatore delle informazioni utili per migliorare il modello del problema da ottimizzare.

La Figura~\ref{schemaIterLearn} mostra lo schema dell'interazione tra il livello globale e il livello locale realizzata tramite l'approccio dell'Apprendimento Automatico. Nella parte alta osserviamo il sistema di supporto alle decisioni, l'ottimizzatore, che, a fronte delle possibili decisioni (l'allocazione di risorse per lo svolgimento di attività per la produzione di energia energetica nel rispetto dei diversi vincoli), produce un piano (oppure un insieme di piani o scenari). Il modello del DSS è arricchito con i vincoli che vengono appresi nella fase di \emph{Learning} a partire dai risultati prodotti dal simulatore; in ingresso al simulatore troviamo un insieme di piani interessanti per la relazione che stiamo tentando di apprendere - ad esempio per studiare il rapporto tra i fondi investiti nel metodo di incentivazione Conto Interessi è stato necessario effettuare simulazioni per un ampio numero di valori di budget. 
\begin{figure}[htb]
	\begin{center}
	\includegraphics[scale=0.65]{schemaIterLearn}
	\end{center}
	\caption{Modello di interazione basato su Apprendimento Automatico}
  	\label{schemaIterLearn}
\end{figure}

La fase di apprendimento, e quindi le simulazioni, devono essere effettuate prima della fase di pianificazione (\emph{offline}), in quanto occorre inserire all'interno del modello i nuovi vincoli appresi, i quali non saranno più modificati (se non nel caso in cui vengano sostituiti da altri ricavati da un nuovo processo di apprendimento). \`E necessario effettuare un grande numero di simulazioni per garantire un valore statistico alle relazioni apprese e fornire un buon insieme di dati tramite cui effettuare l'apprendimento; questo rappresenta sicuramente il maggiore limite di questo tipo di approccio, in quanto comporta che i vincoli appresi non possano essere modificati facilmente - effettuare un gran numero di simulazioni richiede molto tempo - e l'interazione avvenga sostanzialmente in una sola direzione, dall'simulatore verso il DSS. 
\\*\\*
Una seconda metodologia per integrare ottimizzazione e simulazione da noi considerata, nonostante non sia stata concretamente implementata a differenza della prima, è una tecnica classica di decomposizione dei problemi presa in prestito dall'ambito della Ricerca Operativa, la cosiddetta \emph{decomposizione di Benders} \cite{bendersDec}. Essa consiste in un metodo per risolvere problemi di ottimizzazione combinatoria che possono essere scomposti in due componenti, un problema master e un sotto-problema. Originariamente era stata concepita per il campo della Programmazione Lineare Intera ma è stata in seguito estesa per trattare risolutori più generali, \emph{Logic-Based Benders Decomposition} (decomposizione di Benders basata sulla Logica) \cite{Hooker95logic-basedbenders}. 

Nel caso da noi preso in esame il problema master è la definizione del piano energetico regionale che partizioni l'energia necessaria tra le diverse fonti energetiche rinnovabili e viene risolto tramite il modello a vincoli descritto nel capitolo precedente. Il sotto-problema consiste nella definizione della strategia di incentivazione per raggiungere la produzione energetica desiderata, in modo consistente con i vincoli regionali sul budget. Partendo dalle soluzioni ottenute con l'ottimizzazione, ovvero la produzione energetica attesa, per comprendere quale sia il budget corretto da allocare per gli incentivi vengono portate a termine diverse simulazioni - in numero comunque molto inferiore rispetto all'interazione basata sull'Apprendimento Automatico. Nel caso in cui gli incentivi non siano compatibili con il budget regionale viene generato un cosiddetto \emph{taglio di Benders} (chiamati anche \emph{no-good}), cioè un vincolo che va ad aggiungersi al modello del problema master, e successivamente una nuova soluzione viene generata dal DSS. 

A differenza del primo metodo, con questo approccio la comunicazione tra i due componenti qui considerati viene estesa ad un ciclo, come si può facilmente notare in Figura~\ref{schemaIterBend}.

\begin{figure}[htb]
	\begin{center}
	\includegraphics[scale=0.65]{schemaIterBend}
	\end{center}
	\caption{Modello di interazione basato su Decomposizione di Benders}
  	\label{schemaIterBend}
\end{figure}

L'interazione inizia dall'ottimizzatore che fornisce una soluzione per il problema master, soluzione che contiene la produzione energetica attesa da fotovoltaico e dei valori ipotetici della dimensione dei fondi da destinare agli incentivi regionali. Questi valori ipotetici sono passati al simulatore, il quale esegue delle simulazioni esclusivamente con tali parametri forniti dal DSS e produce le corrispondenti statistiche (il tempo di calcolo è di qualche ordine di grandezza minore rispetto all'approccio basato sull'apprendimento); queste ultime possono confermare o meno i valori ipotizzati in fase di ottimizzazione: se il valore (medio) di produzione energetica ottenuto dalle simulazioni è maggiore o uguale di quello atteso, l'iterazione può concludersi è il risultato è probabilmente ottimale \cite{bendersDec}. Viceversa se invece il valore atteso è maggiore di quello simulato un'altra iterazione è necessaria, quindi  all'ottimizzatore è comunicato un nuovo vincolo, il quale può essere visto come spiegazione del fatto che non è possibile ottenere la produzione energetica richiesta con i fondi agli incentivi ipotizzati. A questo punto il DSS inserisce il vincolo all'interno del modello del problema, ricerca nuovamente una soluzione ottimale e ipotizza nuovi valori da fornire in input al simulatore.

La sfida principale consiste nel determinare l'insieme dei vincoli che vengono trasferiti tra le due componenti: se venissero esclusi dall'insieme dei valori ammissibili solamente quelli ipotizzati - e trovati non adatti grazie alle simulazioni - si correrebbe il rischio di effettuare troppe iterazioni, arrivando al caso limite di effettuare una simulazione esaustiva per tutti i parametri (in pratica verrebbero nuovamente fatte delle simulazioni per ogni valore del budget per gli incentivi regionali); se invece dall'insieme dei valori  venissero esclusi (troppi) valori ulteriori il pericolo sarebbe quello di scartare delle soluzioni promettenti. Questo tema e l'implementazione effettiva di questo secondo approccio sono attualmente oggetto di ricerca.

\section{REGRESSIONE LINEARE A TRATTI}
%a33-cattafi -> pag. 8-9
Passiamo ora a discutere del modo in cui l'approccio basato sull'Apprendimento Automatico sia stato implementato nel nostro modello a vincoli.
\\*\\*
Come è stato descritto nel terzo capitolo, tramite un grande numero di simulazioni è stato possibile ottenere una grande quantità di dati dalla quale abbiamo successivamente ricavato le relazioni che legano i fondi per gli incentivi regionale alla produzione energetica da fotovoltaico e quest'ultima alla forza dell'interazione sociale tra gli agenti. Tali relazioni sono state espresse sotto forma di funzioni e corrispondenti curve, ottenute attraverso l'applicazione di tecniche di regressione. A questo punto la nostra intenzione è stata quella di integrare queste funzioni all'interno modello a vincoli del problema di ottimizzazione, aggiungendo cioè i nuovi vincoli appresi grazie alle simulazioni svolte; è sorto quindi un problema, poiché, come descritto nel capitolo precedente, il risolutore dai noi utilizzato l'ottimizzazione gestisce esclusivamente equazioni lineari - per motivi di efficienza. Dal momento che modificare questa caratteristica, ovvero impiegare un risolutore in grado di trattare le funzioni quadratiche e di grado anche superiore ricavate dalla regressione, avrebbe richiesto cambiamenti radicali nella struttura generale e nel codice dell'ottimizzatore, abbiamo ritenuto che fosse meglio procedere in un altro modo, che ci consentisse di preservare la linearità del modello a vincoli sviluppato. Per questo motivo abbiamo deciso di tentare di rendere lineari le relazioni  ottenute con la regressione sfruttando una tecnica matematica definita \emph{approssimazione lineare a tratti} \cite{piecewiseApprox,cattafi} (dall'inglese, \emph{piece-wise linear approximation}), che consiste nell'approssimare un'arbitraria funzione con un insieme di equazioni lineari con la massima accuratezza possibile. Possiamo ad esempio osservare in Figura~\ref{piecewiseApprox_example} l'approssimazione di una semplice funzione quadratica (in blu) attraverso cinque funzioni lineari (in rosso). 

\begin{figure}[htb]
	\begin{center}
	\includegraphics[scale=0.8]{piecewiseApprox_example}
	\end{center}
	\caption{Una funzione (in blu) e la sua approssimazione lineare a tratti (in rosso). Fonte {\tt http://commons.wikimedia.org/wiki/File:Finite\_element\_method\_1D\_illustration1.svg}}
  	\label{piecewiseApprox_example}
\end{figure}

Illustreremo adesso il funzionamento di questo metodo. Data una funzione (anche non lineare) $y=f(x)$, campioniamo la curva $g$ in $k$ punti $x_1,...,x_k$ e l'approssimazione lineare a tratti $y'=g'(x)\simeq g(x)$ è definita come
\begin{equation} 
\label{eq:aprroxEqX}
	x = \sum_{i=1}^k \lambda_i \cdot x_i,
\end{equation}
\begin{equation} 
\label{eq:aprroxEqY}
	y = \sum_{i=1}^k \lambda_i \cdot y_i,
\end{equation}
dove $\lambda_i \in [0..1]$ sono variabili continue soggette ai vincoli:
\begin{equation} 
\label{eq:aprroxEqLambda}
		\sum_{i=1}^k \lambda_i = 1
\end{equation}
Al massimo due $\lambda_i$ possono essere diverse da zero e in tal caso queste devono essere adiacenti.

Chiaramente queste ultime due condizioni non sono lineari, ma potrebbero essere modellate in un problema di Programmazione Logica Intera introducendo nuove 0-1 variabili intere, ma esiste una opzione più efficiente. In molti risolutori - compreso quello da noi impiegato - è possibile dichiarare $(\lambda_1,...,\lambda_k)$ come Special Order Set del secondo tipo (SOS2) \cite{bealeTomlin}, cioè un insieme ordinato di variabili utilizzato per specificare  determinate condizioni in problemi di ottimizzazione, e il risolutore sfrutterà questa informazione per ricercare una soluzione ottimale in modo più efficiente (in pratica, sapere che una variabile appartiene ad un certo insieme ordinato consente di usare in modo più intelligente gli algoritmi di branch-and-bound del solver).

\subsection{IMPLEMENTAZIONE IN R}

Le informazioni necessarie per poter inserire le equazioni (\ref{eq:aprroxEqX}), (\ref{eq:aprroxEqY}) e (\ref{eq:aprroxEqLambda}) all'interno del modello a vincoli sono le coordinate dei punti di campionamento. Per trovarle ci siamo serviti del precedentemente introdotto R e in particolare del pacchetto software \emph{Segmented} \cite{segmentedPackage}. Grazie ad esso è stato molto semplice trovare un'ottima approssimazione lineare per le funzioni che legavano il budget alla produzione energetica (una per ogni tipo di incentivo), come si può facilmente osservare nel codice qui presentato.

\lstset{language=R}
\begin{lstlisting}
> library(segmented)
> #  ...
> # inserisci i dati delle simulazioni in apposite strutture 
> #  ...
> # operazioni varie (ordina dati, etc.)
> #  ...
> # estrai un modello lineare a tratti per l'incentivo Conto Interessi
> modelloLineareATratti_CI <- segmented(modelloGrezzo_CI,seg.Z=~ Budget,psi=c(3))
> # estrai un modello lineare a tratti per l'incentivo Fondo Garanzia
> modelloLineareATratti_FG <- segmented(modelloGrezzo_FG,seg.Z=~ Budget,psi=c(12,30))
> #  ...
> # incentivi restanti
> #  ...
\end{lstlisting}

Una volta ricavate le approssimazioni lineari a tratti delle funzioni, è possibile visualizzare il risultato ottenuto, come riportato in Figura~\ref{incentCompare_piecewise}.

\begin{figure}[hbt]
	\centering
	\includegraphics[scale=0.6]{incentComparePiecewise}
	\caption{Confronto tra i diversi incentivi - Approssimazione lineare a tratti}
	\label{incentCompare_piecewise}
\end{figure}

\section{INTEGRAZIONE MODELLO}

\subsection{VARIABILI}

\subsection{VINCOLI}

\section{ASSEGNAZIONE FONDI}

\myparagraph{FONDO INCENTIVI – 2.5 MILIONI EURO}

\myparagraph{FONDO INCENTIVI – 5 MILIONI EURO}

\myparagraph{FONDO INCENTIVI – 10 MILIONI EURO}

\myparagraph{FONDO INCENTIVI – 15 MILIONI EURO}

\myparagraph{FONDO INCENTIVI – 20 MILIONI EURO}

\myparagraph{FONDO INCENTIVI – 40 MILIONI EURO}

\nocite{*}
\bibliographystyle{plain}
\bibliography{bibliography}

\end{document}
